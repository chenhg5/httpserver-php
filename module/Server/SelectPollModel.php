<?php

namespace HttpServer\Module\Server;


class SelectPollModel extends BaseModel
{
    public function run()
    {
        parent::run(); // TODO: Change the autogenerated stub

        // select/poll 模型 同步非阻塞 IO

        function close($i, &$connections)
        {
            stream_socket_shutdown($connections[ $i ], STREAM_SHUT_RD);
            socket_close($connections[ $i ]);
            unset($connections[ $i ]);
        }

        /* 要监听的三个sockets数组 */
        $readfds = array();
        $writefds = array();
        $except_socks = NULL;  // 注意 php 不支持直接将NULL作为引用传参，所以这里定义一个变量

        $read_socks[] = $this->serv;
        $connections = [];

        while (true) {
            $tmp_readfds = $readfds;
            $tmp_writefds = $writefds;

            // 选择一个连接，获取读、写连接通道
            if (stream_select($tmp_readfds, $tmp_writefds, $e = null, $t = 60)) {
                // 如果是当前服务端的监听连接
                if (in_array($this->serv, $tmp_readfds)) {
                    // 接受客户端连接
                    $newconn = stream_socket_accept($this->serv);
                    $i = (int)$newconn;
                    $reject = '';
                    if (count($connections) >= 1024) {
                        $reject = "Server full, Try again later./n";
                    }
                    // 将当前客户端连接放入 socket_select 选择
                    $connections[ $i ] = $newconn;
                    // 输入的连接资源缓存容器
                    $writefds[ $i ] = $newconn;

                    // 连接不正常
                    if ($reject) {
                        @fwrite($tmp_writefds[ $i ], $reject);
                        unset($tmp_writefds[ $i ]);
                        close($i, $connections);
                    } else {
                        echo "Client $i come./n";
                    }
                    // remove the listening socket from the clients-with-data array
                    $key = array_search($this->serv, $tmp_readfds);
                    unset($tmp_readfds[ $key ]);
                }

                // 轮循读通道
                foreach ($tmp_readfds as $rfd) {
                    // 客户端连接
                    $i = (int)$rfd;
                    // 从通道读取
                    $line = @socket_read($rfd, 2048, PHP_NORMAL_READ);
                    if ($line === false) {
                        // 读取不到内容，结束连接
                        echo "Connection closed on socket $i./n";
                        close($i, $connections);
                        continue;
                    }
                    $tmp = substr($line, -1);
                    if ($tmp != "/r" && $tmp != "/n") {
                        // 等待更多数据
                        continue;
                    }
                    // 处理逻辑
                    $line = trim($line);
                    if ($line == "quit") {
                        echo "Client $i quit./n";
                        close($i, $connections);
                        break;
                    }
                    if ($line) {
                        echo "Client $i >>" . $line . "/n";
                    }
                }

                // 轮循写通道
                foreach ($tmp_writefds as $wfd) {
                    $i = (int)$wfd;
                    socket_write($wfd, "Welcome Client $i!/n");
                }
            }
        }
    }
}